-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Eazy.Par
  ( happyError
  , myLexer
  , pProgram
  ) where

import Prelude

import qualified Eazy.Abs
import Eazy.Lex

}

%name pProgram_internal Program
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '&&'        { PT _ (TS _ 1)       }
  '('         { PT _ (TS _ 2)       }
  ')'         { PT _ (TS _ 3)       }
  '*'         { PT _ (TS _ 4)       }
  '+'         { PT _ (TS _ 5)       }
  ','         { PT _ (TS _ 6)       }
  '-'         { PT _ (TS _ 7)       }
  '->'        { PT _ (TS _ 8)       }
  '/'         { PT _ (TS _ 9)       }
  ':'         { PT _ (TS _ 10)      }
  '::'        { PT _ (TS _ 11)      }
  ';'         { PT _ (TS _ 12)      }
  '<'         { PT _ (TS _ 13)      }
  '<='        { PT _ (TS _ 14)      }
  '='         { PT _ (TS _ 15)      }
  '=/='       { PT _ (TS _ 16)      }
  '=='        { PT _ (TS _ 17)      }
  '>'         { PT _ (TS _ 18)      }
  '>='        { PT _ (TS _ 19)      }
  'False'     { PT _ (TS _ 20)      }
  'True'      { PT _ (TS _ 21)      }
  '['         { PT _ (TS _ 22)      }
  ']'         { PT _ (TS _ 23)      }
  '_'         { PT _ (TS _ 24)      }
  'as'        { PT _ (TS _ 25)      }
  'if'        { PT _ (TS _ 26)      }
  'in'        { PT _ (TS _ 27)      }
  'lambda:'   { PT _ (TS _ 28)      }
  'let'       { PT _ (TS _ 29)      }
  'match'     { PT _ (TS _ 30)      }
  'otherwise' { PT _ (TS _ 31)      }
  'type'      { PT _ (TS _ 32)      }
  'with'      { PT _ (TS _ 33)      }
  '{'         { PT _ (TS _ 34)      }
  '|'         { PT _ (TS _ 35)      }
  '||'        { PT _ (TS _ 36)      }
  '}'         { PT _ (TS _ 37)      }
  '~'         { PT _ (TS _ 38)      }
  L_integ     { PT _ (TI _)         }
  L_VarIdent  { PT _ (T_VarIdent _) }
  L_ConIdent  { PT _ (T_ConIdent _) }

%%

Integer :: { (Eazy.Abs.BNFC'Position, Integer) }
Integer  : L_integ  { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), (read (tokenText $1)) :: Integer) }

VarIdent :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.VarIdent) }
VarIdent  : L_VarIdent { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.VarIdent (tokenText $1)) }

ConIdent :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.ConIdent) }
ConIdent  : L_ConIdent { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ConIdent (tokenText $1)) }

Program :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Program) }
Program
  : ListDecl { (fst $1, Eazy.Abs.ProgramT (fst $1) (snd $1)) }

ListVarIdent :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.VarIdent]) }
ListVarIdent
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | VarIdent ListVarIdent { (fst $1, (:) (snd $1) (snd $2)) }

Literal :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Literal) }
Literal
  : Integer { (fst $1, Eazy.Abs.LitInt (fst $1) (snd $1)) }
  | 'True' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.LitTrue (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | 'False' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.LitFalse (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }

SimpleType :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.SimpleType) }
SimpleType
  : ConIdent ListVarIdent { (fst $1, Eazy.Abs.SimpleTypeT (fst $1) (snd $1) (snd $2)) }

Constr :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Constr) }
Constr
  : ConIdent ListType2 { (fst $1, Eazy.Abs.ConstrT (fst $1) (snd $1) (snd $2)) }

Type :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Type) }
Type
  : Type1 '->' Type { (fst $1, Eazy.Abs.TypArr (fst $1) (snd $1) (snd $3)) }
  | Type1 { (fst $1, (snd $1)) }

Type1 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Type) }
Type1
  : ConIdent Type2 ListType2 { (fst $1, Eazy.Abs.TypApp (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Type2 { (fst $1, (snd $1)) }

Type2 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Type) }
Type2
  : VarIdent { (fst $1, Eazy.Abs.TypVar (fst $1) (snd $1)) }
  | ConIdent { (fst $1, Eazy.Abs.TypCon (fst $1) (snd $1)) }
  | '[' Type ']' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.TypLst (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '(' Type ')' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListConstr :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Constr]) }
ListConstr
  : Constr { (fst $1, (:[]) (snd $1)) }
  | Constr '|' ListConstr { (fst $1, (:) (snd $1) (snd $3)) }

ListType2 :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Type]) }
ListType2
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | Type2 ListType2 { (fst $1, (:) (snd $1) (snd $2)) }

Decl :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Decl) }
Decl
  : 'type' SimpleType '=' ListConstr { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.DeclData (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | VarIdent ListVarIdent '=' Expr { (fst $1, Eazy.Abs.DeclFunc (fst $1) (snd $1) (snd $2) (snd $4)) }
  | VarIdent ':' Type { (fst $1, Eazy.Abs.DeclFunT (fst $1) (snd $1) (snd $3)) }

ListDecl :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Decl]) }
ListDecl
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | Decl { (fst $1, (:[]) (snd $1)) }
  | Decl ';' ListDecl { (fst $1, (:) (snd $1) (snd $3)) }

Expr :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr
  : Expr3 'if' Expr 'otherwise' Expr { (fst $1, Eazy.Abs.ExpIf (fst $1) (snd $1) (snd $3) (snd $5)) }
  | 'match' Expr 'with' '{' ListMatch '}' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpMth (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $5)) }
  | 'let' '{' ListDecl '}' 'in' Expr { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpLet (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $3) (snd $6)) }
  | 'lambda:' ListVarIdent '->' Expr { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpLmb (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2) (snd $4)) }
  | Expr1 '||' Expr { (fst $1, Eazy.Abs.ExpOr (fst $1) (snd $1) (snd $3)) }
  | Expr1 { (fst $1, (snd $1)) }

Expr1 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr1
  : Expr2 '&&' Expr1 { (fst $1, Eazy.Abs.ExpAnd (fst $1) (snd $1) (snd $3)) }
  | Expr2 { (fst $1, (snd $1)) }

Expr2 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr2
  : Expr2 CmpOp Expr3 { (fst $1, Eazy.Abs.ExpCmp (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr2 EqsOp Expr3 { (fst $1, Eazy.Abs.ExpEqs (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr3 { (fst $1, (snd $1)) }

Expr3 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr3
  : Expr3 AddOp Expr4 { (fst $1, Eazy.Abs.ExpAdd (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr4 { (fst $1, (snd $1)) }

Expr4 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr4
  : Expr4 MulOp Expr5 { (fst $1, Eazy.Abs.ExpMul (fst $1) (snd $1) (snd $2) (snd $3)) }
  | Expr5 { (fst $1, (snd $1)) }

Expr5 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr5
  : Expr6 '::' Expr5 { (fst $1, Eazy.Abs.ExpChn (fst $1) (snd $1) (snd $3)) }
  | Expr6 { (fst $1, (snd $1)) }

Expr6 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr6
  : '~' Expr7 { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpNot (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | '-' Expr7 { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpNeg (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Expr7 { (fst $1, (snd $1)) }

Expr7 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr7
  : Expr7 Expr8 { (fst $1, Eazy.Abs.ExpApp (fst $1) (snd $1) (snd $2)) }
  | Expr8 { (fst $1, (snd $1)) }

Expr8 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Expr) }
Expr8
  : '[' ListExpr ']' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.ExpLst (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Literal { (fst $1, Eazy.Abs.ExpLit (fst $1) (snd $1)) }
  | ConIdent { (fst $1, Eazy.Abs.ExpCon (fst $1) (snd $1)) }
  | VarIdent { (fst $1, Eazy.Abs.ExpVar (fst $1) (snd $1)) }
  | '(' Expr ')' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

ListExpr :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Expr]) }
ListExpr
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | Expr { (fst $1, (:[]) (snd $1)) }
  | Expr ',' ListExpr { (fst $1, (:) (snd $1) (snd $3)) }

AddOp :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.AddOp) }
AddOp
  : '+' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpAdd (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '-' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpSub (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }

MulOp :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.MulOp) }
MulOp
  : '*' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpMul (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '/' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpDiv (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }

EqsOp :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.EqsOp) }
EqsOp
  : '==' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpEq (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '=/=' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpNeq (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }

CmpOp :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.CmpOp) }
CmpOp
  : '>' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpGrt (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '>=' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpGeq (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpLrt (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '<=' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.OpLeq (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }

Match :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Match) }
Match
  : AbsPattern '->' Expr { (fst $1, Eazy.Abs.MatchT (fst $1) (snd $1) (snd $3)) }

AbsPattern :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.AbsPattern) }
AbsPattern
  : Pattern 'as' VarIdent { (fst $1, Eazy.Abs.PatAs (fst $1) (snd $1) (snd $3)) }
  | Pattern { (fst $1, Eazy.Abs.Pat (fst $1) (snd $1)) }

Pattern :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Pattern) }
Pattern
  : ConIdent ListSubPat { (fst $1, Eazy.Abs.PatCon (fst $1) (snd $1) (snd $2)) }
  | Pattern1 { (fst $1, (snd $1)) }

Pattern1 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Pattern) }
Pattern1
  : Pattern2 '::' Pattern1 { (fst $1, Eazy.Abs.PatLL (fst $1) (snd $1) (snd $3)) }
  | Pattern2 { (fst $1, (snd $1)) }

Pattern2 :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.Pattern) }
Pattern2
  : '[' ListPattern ']' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.PatLst (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1)) (snd $2)) }
  | Literal { (fst $1, Eazy.Abs.PatLit (fst $1) (snd $1)) }
  | VarIdent { (fst $1, Eazy.Abs.PatVar (fst $1) (snd $1)) }
  | '_' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), Eazy.Abs.PatDef (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1))) }
  | '(' Pattern ')' { (uncurry Eazy.Abs.BNFC'Position (tokenLineCol $1), (snd $2)) }

SubPat :: { (Eazy.Abs.BNFC'Position, Eazy.Abs.SubPat) }
SubPat : Pattern2 { (fst $1, Eazy.Abs.SubPatT (fst $1) (snd $1)) }

ListMatch :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Match]) }
ListMatch
  : Match ';' { (fst $1, (:[]) (snd $1)) }
  | Match ';' ListMatch { (fst $1, (:) (snd $1) (snd $3)) }

ListPattern :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.Pattern]) }
ListPattern
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | Pattern { (fst $1, (:[]) (snd $1)) }
  | Pattern ',' ListPattern { (fst $1, (:) (snd $1) (snd $3)) }

ListSubPat :: { (Eazy.Abs.BNFC'Position, [Eazy.Abs.SubPat]) }
ListSubPat
  : {- empty -} { (Eazy.Abs.BNFC'NoPosition, []) }
  | SubPat ListSubPat { (fst $1, (:) (snd $1) (snd $2)) }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

-- Entrypoints

pProgram :: [Token] -> Err Eazy.Abs.Program
pProgram = fmap snd . pProgram_internal
}

